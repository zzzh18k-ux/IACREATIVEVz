<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Casino 777 Free</title>
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='//libtl.com/sdk.js' data-zone='10278425' data-sdk='show_10278425'></script>
    <script src="https://sad.adsgram.ai/js/sad.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #020617;
            color: #ffffff;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }
        .font-bebas { font-family: 'Bebas Neue', cursive; }
        
        @keyframes bounce-subtle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        .animate-bounce { animation: bounce-subtle 2s ease-in-out infinite; }
        
        /* Ocultar barra de scroll */
        ::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- CONSTANTES DEL JUEGO (TraÃ­das de types.ts) ---
        const GAME_CONSTANTS = {
            SAVE_KEY: 'casino777free_core_v1',
            WELCOME_BONUS: 0.10,
            WITHDRAW_THRESHOLD: 0.20,
            AD_REWARD: 0.0004, 
            DAILY_BONUS_REWARD: 0.005,
            MIN_BET: 0.001,
            COOLDOWN_24H: 24 * 60 * 60 * 1000,
            TEAM_COMMISSION_PCT: 0.10, 
        };

        // --- MOTOR DE SONIDO ---
        const playSound = (type, muted) => {
            if (muted) return;
            // Verificar soporte de AudioContext
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            
            const audioCtx = new AudioContext();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            switch (type) {
                case 'click':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;
                case 'diamond':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(800, now);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    oscillator.start(now);
                    oscillator.stop(now + 0.2);
                    break;
                case 'bomb':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, now);
                    oscillator.frequency.linearRampToValueAtTime(40, now + 0.3);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
                    oscillator.start(now);
                    oscillator.stop(now + 0.3);
                    break;
                case 'win':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523.25, now);
                    oscillator.frequency.setValueAtTime(659.25, now + 0.1);
                    oscillator.frequency.setValueAtTime(783.99, now + 0.2);
                    oscillator.frequency.setValueAtTime(1046.50, now + 0.3);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0.1, now + 0.4);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    oscillator.start(now);
                    oscillator.stop(now + 0.6);
                    break;
                case 'lose':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(150, now);
                    oscillator.frequency.linearRampToValueAtTime(70, now + 0.4);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0.01, now + 0.4);
                    oscillator.start(now);
                    oscillator.stop(now + 0.4);
                    break;
                case 'flip':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                    gainNode.gain.setValueAtTime(0.05, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;
                case 'cash':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(900, now);
                    oscillator.frequency.exponentialRampToValueAtTime(1500, now + 0.2);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    oscillator.start(now);
                    oscillator.stop(now + 0.3);
                    break;
            }
        };

        // --- COMPONENTE PRINCIPAL (App.tsx convertido) ---
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        const App = () => {
            const tg = window.Telegram?.WebApp;
            
            const userId = useMemo(() => {
                const telegramId = tg?.initDataUnsafe?.user?.id;
                if (telegramId) return telegramId.toString();
                
                const savedId = localStorage.getItem('casino777_stable_id');
                if (savedId) return savedId;
                
                const newId = 'user_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('casino777_stable_id', newId);
                return newId;
            }, [tg]);

            const [user, setUser] = useState(() => {
                const saved = localStorage.getItem(GAME_CONSTANTS.SAVE_KEY);
                if (saved) {
                try {
                    const data = JSON.parse(atob(saved));
                    return {
                    balance: data.balance ?? GAME_CONSTANTS.WELCOME_BONUS,
                    withdrawals: data.withdrawals ?? [],
                    betHistory: data.betHistory ?? [],
                    lastVideoClaims: data.lastVideoClaims ?? {},
                    lastDailyBonus: data.lastDailyBonus ?? 0,
                    teamEarnings: data.teamEarnings ?? 0,
                    totalTeamEarnings: data.totalTeamEarnings ?? 0,
                    referralCount: data.referralCount ?? 0
                    };
                } catch (e) { console.error("Error loading save:", e); }
                }
                return { 
                balance: GAME_CONSTANTS.WELCOME_BONUS, 
                withdrawals: [],
                betHistory: [],
                lastVideoClaims: {},
                lastDailyBonus: 0,
                teamEarnings: 0,
                totalTeamEarnings: 0,
                referralCount: 0
                };
            });

            const [currentGame, setCurrentGame] = useState(null);
            const [currentBet, setCurrentBet] = useState(GAME_CONSTANTS.MIN_BET);
            const [isSpinning, setIsSpinning] = useState(false);
            const [showWithdrawModal, setShowWithdrawModal] = useState(false);
            const [showWithdrawHistory, setShowWithdrawHistory] = useState(false);
            const [showBetHistory, setShowBetHistory] = useState(false);
            const [showTeamModal, setShowTeamModal] = useState(false);
            const [gameResult, setGameResult] = useState(null);
            const [videoTimers, setVideoTimers] = useState({});
            const [dailyBonusTimer, setDailyBonusTimer] = useState("");
            const [isAdLoading, setIsAdLoading] = useState(false);
            const [isMuted, setIsMuted] = useState(() => localStorage.getItem('casino_muted') === 'true');

            // Estado para Minas
            const [minesCount, setMinesCount] = useState(3);
            const [minesGrid, setMinesGrid] = useState(Array(25).fill(null));
            const [bombPositions, setBombPositions] = useState([]);
            const [minesGameOver, setMinesGameOver] = useState(false);
            const [revealedCount, setRevealedCount] = useState(0);
            const [multiplier, setMultiplier] = useState(1);

            const withdrawProgress = useMemo(() => {
                const progress = (user.balance / GAME_CONSTANTS.WITHDRAW_THRESHOLD) * 100;
                return Math.min(progress, 100);
            }, [user.balance]);

            useEffect(() => {
                localStorage.setItem(GAME_CONSTANTS.SAVE_KEY, btoa(JSON.stringify(user)));
            }, [user]);

            useEffect(() => {
                localStorage.setItem('casino_muted', isMuted.toString());
            }, [isMuted]);

            useEffect(() => {
                const updateTimers = () => {
                const now = Date.now();
                const vTimers = {};
                [1, 2, 3, 4, 5, 6, 7].forEach(id => {
                    const last = user.lastVideoClaims?.[id];
                    if (last) {
                    const diff = (last + GAME_CONSTANTS.COOLDOWN_24H) - now;
                    if (diff > 0) {
                        const h = Math.floor(diff / 3600000);
                        const m = Math.floor((diff % 3600000) / 60000);
                        vTimers[id] = `${h}h ${m}m`;
                    }
                    }
                });
                setVideoTimers(vTimers);

                if (user.lastDailyBonus) {
                    const diff = (user.lastDailyBonus + GAME_CONSTANTS.COOLDOWN_24H) - now;
                    if (diff > 0) {
                    const h = Math.floor(diff / 3600000);
                    const m = Math.floor((diff % 3600000) / 60000);
                    const s = Math.floor((diff % 60000) / 1000);
                    setDailyBonusTimer(`${h}h ${m}m ${s}s`);
                    } else {
                    setDailyBonusTimer("");
                    }
                }
                };
                const t = setInterval(updateTimers, 1000);
                updateTimers();
                return () => clearInterval(t);
            }, [user.lastVideoClaims, user.lastDailyBonus]);

            useEffect(() => {
                if (tg) {
                tg.ready();
                tg.expand();
                if (tg.isVersionAtLeast && tg.isVersionAtLeast('6.1')) {
                    tg.setHeaderColor('#020617');
                    tg.setBackgroundColor('#020617');
                }
                }
            }, [tg]);

            const triggerHaptic = (type = 'light') => {
                if (tg?.HapticFeedback && tg.isVersionAtLeast && tg.isVersionAtLeast('6.0')) {
                try {
                    if (type === 'success') tg.HapticFeedback.notificationOccurred('success');
                    else if (type === 'error') tg.HapticFeedback.notificationOccurred('error');
                    else tg.HapticFeedback.impactOccurred('medium');
                } catch (e) { console.warn("Haptic failed", e); }
                }
            };

            const getInviteLink = () => {
                return `https://t.me/Casino777free/play?startapp=${userId}`;
            };

            const handleShare = (text) => {
                playSound('click', isMuted);
                const shareText = text || `Â¡Ãšnete a mi equipo en Casino 777 Free y gana USDT conmigo! ðŸ”¥ðŸ’° Mi balance es de $${user.balance.toFixed(4)} USDT.`;
                const shareUrl = getInviteLink();

                if (tg?.isVersionAtLeast && tg.isVersionAtLeast('6.0')) {
                tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(shareText)}`);
                } else {
                copyToClipboard(`${shareText} ${shareUrl}`);
                }
            };

            const copyToClipboard = (text) => {
                const el = document.createElement('textarea');
                el.value = text;
                document.body.appendChild(el);
                el.select();
                document.execCommand('copy');
                document.body.removeChild(el);
                tg?.showAlert("Â¡Enlace copiado al portapapeles!");
            };

            const handleDailyBonus = async () => {
                if (dailyBonusTimer) return tg?.showAlert(`Espera ${dailyBonusTimer} para tu prÃ³ximo bono.`);
                playSound('click', isMuted);
                setIsAdLoading(true);
                try {
                if (window.show_10278425) {
                    await window.show_10278425();
                    setUser(prev => ({
                    ...prev,
                    balance: prev.balance + GAME_CONSTANTS.DAILY_BONUS_REWARD,
                    lastDailyBonus: Date.now()
                    }));
                    playSound('win', isMuted);
                    tg?.showAlert(`Â¡Bono Diario de $${GAME_CONSTANTS.DAILY_BONUS_REWARD.toFixed(4)} USDT reclamado!`);
                } else {
                    tg?.showAlert("Anuncios no disponibles actualmente.");
                }
                } catch(e) { console.error("Daily Bonus Error:", e); } finally { setIsAdLoading(false); }
            };

            const handleVideo = async (id) => {
                if (videoTimers[id]) return tg?.showAlert("Espera a que termine el tiempo");
                playSound('click', isMuted);
                setIsAdLoading(true);
                try {
                if (window.show_10278425) {
                    await window.show_10278425();
                    setUser(prev => ({
                    ...prev,
                    balance: prev.balance + GAME_CONSTANTS.AD_REWARD,
                    lastVideoClaims: { ...prev.lastVideoClaims, [id]: Date.now() }
                    }));
                    playSound('win', isMuted);
                    tg?.showAlert(`+$${GAME_CONSTANTS.AD_REWARD} USDT aÃ±adidos`);
                }
                } catch(e) { console.error("Video error:", e); } finally { setIsAdLoading(false); }
            };

            const addBetRecord = (game, bet, profit, win) => {
                const record = {
                id: Math.random().toString(36).substr(2, 9),
                game, bet, profit, win,
                date: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                };
                setUser(prev => ({ ...prev, betHistory: [record, ...prev.betHistory].slice(0, 50) }));
            };

            const startMines = () => {
                if (user.balance < currentBet) return tg?.showAlert("Saldo insuficiente");
                playSound('click', isMuted);
                setUser(prev => ({ ...prev, balance: prev.balance - currentBet }));
                const bombs = [];
                while(bombs.length < minesCount) {
                const p = Math.floor(Math.random() * 25);
                if(!bombs.includes(p)) bombs.push(p);
                }
                setBombPositions(bombs);
                setMinesGrid(Array(25).fill(null));
                setMinesGameOver(false);
                setRevealedCount(0);
                setMultiplier(1);
                setIsSpinning(true);
                setGameResult(null);
            };

            const revealTile = (i) => {
                if (!isSpinning || minesGameOver || minesGrid[i]) return;
                if (bombPositions.includes(i)) {
                playSound('bomb', isMuted);
                const g = [...minesGrid];
                bombPositions.forEach(b => g[b] = 'ðŸ’£');
                setMinesGrid(g);
                setMinesGameOver(true);
                setIsSpinning(false);
                setGameResult({ msg: "BOOM! Perdiste", win: false });
                addBetRecord("Minas", currentBet, -currentBet, false);
                triggerHaptic('error');
                } else {
                playSound('diamond', isMuted);
                const g = [...minesGrid];
                g[i] = 'ðŸ’Ž';
                setMinesGrid(g);
                
                const currentRevealed = revealedCount;
                const totalTiles = 25;
                const remainingTiles = totalTiles - currentRevealed;
                const safeTilesRemaining = (totalTiles - minesCount) - currentRevealed;
                
                const stepMultiplier = remainingTiles / safeTilesRemaining;
                const newMultiplier = multiplier * stepMultiplier;
                
                setMultiplier(newMultiplier);
                setRevealedCount(currentRevealed + 1);
                triggerHaptic('light');
                }
            };

            const cashOutMines = () => {
                playSound('win', isMuted);
                const win = currentBet * multiplier;
                const profit = win - currentBet;
                const commission = profit > 0 ? profit * GAME_CONSTANTS.TEAM_COMMISSION_PCT : 0;
                
                setUser(prev => ({ 
                ...prev, 
                balance: prev.balance + win,
                teamEarnings: prev.teamEarnings + commission
                }));
                
                addBetRecord("Minas", currentBet, profit, true);
                setMinesGameOver(true);
                setIsSpinning(false);
                setGameResult({ msg: `Ganaste $${win.toFixed(4)}`, win: true });
                triggerHaptic('success');
            };

            const getNextMinesMultiplier = () => {
                const totalTiles = 25;
                const currentRevealed = revealedCount;
                const remainingTiles = totalTiles - currentRevealed;
                const safeTilesRemaining = (totalTiles - minesCount) - currentRevealed;
                if (safeTilesRemaining <= 0) return multiplier;
                const stepMultiplier = remainingTiles / safeTilesRemaining;
                return multiplier * stepMultiplier;
            };

            const playCoin = (choice) => {
                if (user.balance < currentBet) return tg?.showAlert("Saldo insuficiente");
                playSound('click', isMuted);
                setIsSpinning(true);
                setUser(prev => ({ ...prev, balance: prev.balance - currentBet }));
                
                setTimeout(() => {
                const isHeads = Math.random() > 0.5;
            
