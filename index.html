<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Gold Miner Classic</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-family: 'Press Start 2P', cursive; /* Fuente estilo arcade */
            overflow: hidden;
            touch-action: none; /* Evita zoom y scroll en m√≥viles */
        }

        #ui-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: #222;
            box-sizing: border-box;
            font-size: 12px;
            border-bottom: 2px solid #555;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 80vh; /* Altura del √°rea de juego */
            background: linear-gradient(to bottom, #87CEEB 15%, #8B4513 15%); /* Cielo y Tierra */
            overflow: hidden;
            border-bottom: 2px solid #555;
        }

        /* El √°rea donde se dibuja el juego */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* Mensajes flotantes (cuando ganas dinero) */
        .float-score {
            position: absolute;
            color: #FFD700;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
    </style>
</head>
<body>

    <div id="ui-bar">
        <div>DINERO: $<span id="score">0</span></div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    <p style="font-size: 10px; color: #aaa; margin-top: 5px;">TOCA LA PANTALLA PARA LANZAR EL GANCHO</p>

    <script>
        // Inicializar Telegram (opcional, para que se vea bien en la app)
        const tg = window.Telegram.WebApp; 
        tg.expand();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const container = document.getElementById('game-container');

        // Ajustar el tama√±o del canvas a la resoluci√≥n real de la pantalla
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- VARIABLES DEL JUEGO ---
        let score = 0;
        let gameState = 'AIMING'; // Estados: AIMING (apuntando), FIRING (disparando), RETURNING (recogiendo)
        const groundLevel = canvas.height * 0.15; // Donde empieza la tierra

        // --- EL GANCH√ì (MINERO) ---
        const miner = {
            x: canvas.width / 2,
            y: groundLevel - 20,
            draw: function() {
                ctx.font = "40px Arial";
                ctx.textAlign = "center";
                ctx.fillText("üë∑‚Äç‚ôÇÔ∏è", this.x, this.y);
            }
        };

        const hook = {
            x: canvas.width / 2,
            y: groundLevel - 10, // Punto de pivote
            length: 30,
            minLength: 30,
            maxLength: canvas.height + 50,
            angle: Math.PI / 2, // Empieza apuntando abajo (90 grados)
            swingSpeed: 0.03,
            swingDir: 1,
            baseSpeed: 8, // Velocidad normal de disparo
            currentSpeed: 8,
            caughtItem: null,
            
            update: function() {
                // L√≥gica de movimiento seg√∫n el estado
                if (gameState === 'AIMING') {
                    // Oscilaci√≥n tipo p√©ndulo
                    this.angle += this.swingSpeed * this.swingDir;
                    if (this.angle > Math.PI - 0.2 || this.angle < 0.2) {
                        this.swingDir *= -1;
                    }
                    this.length = this.minLength;

                } else if (gameState === 'FIRING') {
                    // Bajando
                    this.length += this.currentSpeed;
                    // Si llega al l√≠mite o toca los bordes, regresa
                    let tipX = this.x + Math.cos(this.angle) * this.length;
                    let tipY = this.y + Math.sin(this.angle) * this.length;
                    
                    if (this.length >= this.maxLength || tipX < 0 || tipX > canvas.width || tipY > canvas.height) {
                        gameState = 'RETURNING';
                    }

                } else if (gameState === 'RETURNING') {
                    // Subiendo
                    this.length -= this.currentSpeed;
                    if (this.length <= this.minLength) {
                        this.length = this.minLength;
                        gameState = 'AIMING';
                        
                        // Procesar objeto atrapado al llegar arriba
                        if (this.caughtItem) {
                            score += this.caughtItem.value;
                            scoreEl.innerText = score;
                            showFloatText(`+$${this.caughtItem.value}`, this.x, this.y);
                            // Eliminar el objeto del juego
                            items = items.filter(i => i !== this.caughtItem);
                            this.caughtItem = null;
                            this.currentSpeed = this.baseSpeed; // Resetear velocidad
                        }
                    }
                }
            },

            draw: function() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                // Calcular la punta del gancho
                let tipX = this.x + Math.cos(this.angle) * this.length;
                let tipY = this.y + Math.sin(this.angle) * this.length;
                ctx.lineTo(tipX, tipY);
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Dibujar el ancla en la punta
                ctx.save();
                ctx.translate(tipX, tipY);
                ctx.rotate(this.angle - Math.PI/2); // Rotar el emoji para que apunte bien
                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("ü™ù", 0, 0);
                ctx.restore();

                // Si trae algo, dibujarlo en la punta
                if(this.caughtItem && gameState === 'RETURNING') {
                    this.caughtItem.x = tipX;
                    this.caughtItem.y = tipY + this.caughtItem.radius/2;
                    this.caughtItem.draw();
                }
            },
            
            reset: function() {
                gameState = 'AIMING';
                this.length = this.minLength;
                this.caughtItem = null;
                this.currentSpeed = this.baseSpeed;
            }
        };

        // --- OBJETOS (CLASE) ---
        class Item {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.caught = false;

                // Configuraci√≥n seg√∫n el tipo
                switch(type) {
                    case 'gold_big':
                        this.emoji = 'üí∞'; this.radius = 35; this.value = 500; this.weight = 5; break;
                    case 'gold_small':
                        this.emoji = 'üåï'; this.radius = 15; this.value = 100; this.weight = 1; break;
                    case 'rock_big':
                        this.emoji = 'ü™®'; this.radius = 30; this.value = 10; this.weight = 7; break;
                    case 'rock_small':
                        this.emoji = 'ü™®'; this.radius = 15; this.value = 5; this.weight = 3; break;
                    case 'bomb':
                        this.emoji = 'üí£'; this.radius = 20; this.value = -200; this.weight = 0; break;
                }
            }

            draw() {
                if(this.caught) return; // Si ya lo trae el gancho, no lo dibujamos aqu√≠
                ctx.font = `${this.radius * 2}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.emoji, this.x, this.y);
                
                // (Opcional) Dibujar c√≠rculo de colisi√≥n para depurar
                // ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.stroke();
            }
        }

        let items = [];

        function generateLevel() {
            items = [];
            // Generar objetos aleatorios en la zona de tierra
            for(let i=0; i<15; i++) {
                let types = ['gold_big', 'gold_small', 'gold_small', 'rock_big', 'rock_small', 'rock_small', 'bomb'];
                let type = types[Math.floor(Math.random() * types.length)];
                let x = Math.random() * (canvas.width - 60) + 30;
                let y = groundLevel + 50 + Math.random() * (canvas.height - groundLevel - 100);
                items.push(new Item(type, x, y));
            }
        }

        // --- CONTROL PRINCIPAL (LANZAR) ---
        canvas.addEventListener('pointerdown', () => { // pointerdown funciona mejor en m√≥viles
            if (gameState === 'AIMING') {
                gameState = 'FIRING';
                hook.currentSpeed = hook.baseSpeed;
            }
        });

        // --- COLISIONES ---
        function checkCollisions() {
            if (gameState !== 'FIRING') return;

            let tipX = hook.x + Math.cos(hook.angle) * hook.length;
            let tipY = hook.y + Math.sin(hook.angle) * hook.length;

            for (let item of items) {
                if (item.caught) continue;

                // Distancia simple entre dos puntos
                let dx = tipX - item.x;
                let dy = tipY - item.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < item.radius + 5) { // +5 margen para el gancho
                    // ¬°IMPACTO!
                    
                    if(item.type === 'bomb') {
                        // L√≥gica de bomba
                        gameState = 'RETURNING';
                        hook.currentSpeed = hook.baseSpeed * 2; // Regresa r√°pido
                        score += item.value; // Resta puntos
                        if(score < 0) score = 0;
                        scoreEl.innerText = score;
                        showFloatText("üí• BOMBA! -$200", tipX, tipY, 'red');
                        // Eliminar bomba y objetos cercanos
                        items = items.filter(i => i !== item && Math.sqrt((i.x-item.x)**2 + (i.y-item.y)**2) > 100);

                    } else {
                        // Agarrar objeto
                        gameState = 'RETURNING';
                        hook.caughtItem = item;
                        item.caught = true;
                        // Calcular velocidad de retorno seg√∫n peso (m√°s peso, menos velocidad)
                        hook.currentSpeed = Math.max(1.5, hook.baseSpeed - item.weight);
                    }
                    break; // Solo agarra uno a la vez
                }
            }
        }

        function showFloatText(text, x, y, color = '#FFD700') {
            let el = document.createElement('div');
            el.className = 'float-score';
            el.innerText = text;
            el.style.left = (container.offsetLeft + x) + 'px';
            el.style.top = (container.offsetTop + y) + 'px';
            el.style.color = color;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // --- BUCLE PRINCIPAL DEL JUEGO ---
        function gameLoop() {
            // 1. Limpiar pantalla
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Actualizar l√≥gica
            hook.update();
            checkCollisions();

            // 3. Dibujar todo
            miner.draw();
            for(let item of items) {
                item.draw();
            }
            hook.draw();

            requestAnimationFrame(gameLoop);
        }

        // INICIAR
        generateLevel();
        gameLoop();

    </script>
</body>
            </html><!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>Gold Miner Classic</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-family: 'Press Start 2P', cursive; /* Fuente estilo arcade */
            overflow: hidden;
            touch-action: none; /* Evita zoom y scroll en m√≥viles */
        }

        #ui-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: #222;
            box-sizing: border-box;
            font-size: 12px;
            border-bottom: 2px solid #555;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 80vh; /* Altura del √°rea de juego */
            background: linear-gradient(to bottom, #87CEEB 15%, #8B4513 15%); /* Cielo y Tierra */
            overflow: hidden;
            border-bottom: 2px solid #555;
        }

        /* El √°rea donde se dibuja el juego */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* Mensajes flotantes (cuando ganas dinero) */
        .float-score {
            position: absolute;
            color: #FFD700;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
    </style>
</head>
<body>

    <div id="ui-bar">
        <div>DINERO: $<span id="score">0</span></div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    <p style="font-size: 10px; color: #aaa; margin-top: 5px;">TOCA LA PANTALLA PARA LANZAR EL GANCHO</p>

    <script>
        // Inicializar Telegram (opcional, para que se vea bien en la app)
        const tg = window.Telegram.WebApp; 
        tg.expand();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const container = document.getElementById('game-container');

        // Ajustar el tama√±o del canvas a la resoluci√≥n real de la pantalla
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- VARIABLES DEL JUEGO ---
        let score = 0;
        let gameState = 'AIMING'; // Estados: AIMING (apuntando), FIRING (disparando), RETURNING (recogiendo)
        const groundLevel = canvas.height * 0.15; // Donde empieza la tierra

        // --- EL GANCH√ì (MINERO) ---
        const miner = {
            x: canvas.width / 2,
            y: groundLevel - 20,
            draw: function() {
                ctx.font = "40px Arial";
                ctx.textAlign = "center";
                ctx.fillText("üë∑‚Äç‚ôÇÔ∏è", this.x, this.y);
            }
        };

        const hook = {
            x: canvas.width / 2,
            y: groundLevel - 10, // Punto de pivote
            length: 30,
            minLength: 30,
            maxLength: canvas.height + 50,
            angle: Math.PI / 2, // Empieza apuntando abajo (90 grados)
            swingSpeed: 0.03,
            swingDir: 1,
            baseSpeed: 8, // Velocidad normal de disparo
            currentSpeed: 8,
            caughtItem: null,
            
            update: function() {
                // L√≥gica de movimiento seg√∫n el estado
                if (gameState === 'AIMING') {
                    // Oscilaci√≥n tipo p√©ndulo
                    this.angle += this.swingSpeed * this.swingDir;
                    if (this.angle > Math.PI - 0.2 || this.angle < 0.2) {
                        this.swingDir *= -1;
                    }
                    this.length = this.minLength;

                } else if (gameState === 'FIRING') {
                    // Bajando
                    this.length += this.currentSpeed;
                    // Si llega al l√≠mite o toca los bordes, regresa
                    let tipX = this.x + Math.cos(this.angle) * this.length;
                    let tipY = this.y + Math.sin(this.angle) * this.length;
                    
                    if (this.length >= this.maxLength || tipX < 0 || tipX > canvas.width || tipY > canvas.height) {
                        gameState = 'RETURNING';
                    }

                } else if (gameState === 'RETURNING') {
                    // Subiendo
                    this.length -= this.currentSpeed;
                    if (this.length <= this.minLength) {
                        this.length = this.minLength;
                        gameState = 'AIMING';
                        
                        // Procesar objeto atrapado al llegar arriba
                        if (this.caughtItem) {
                            score += this.caughtItem.value;
                            scoreEl.innerText = score;
                            showFloatText(`+$${this.caughtItem.value}`, this.x, this.y);
                            // Eliminar el objeto del juego
                            items = items.filter(i => i !== this.caughtItem);
                            this.caughtItem = null;
                            this.currentSpeed = this.baseSpeed; // Resetear velocidad
                        }
                    }
                }
            },

            draw: function() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                // Calcular la punta del gancho
                let tipX = this.x + Math.cos(this.angle) * this.length;
                let tipY = this.y + Math.sin(this.angle) * this.length;
                ctx.lineTo(tipX, tipY);
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Dibujar el ancla en la punta
                ctx.save();
                ctx.translate(tipX, tipY);
                ctx.rotate(this.angle - Math.PI/2); // Rotar el emoji para que apunte bien
                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("ü™ù", 0, 0);
                ctx.restore();

                // Si trae algo, dibujarlo en la punta
                if(this.caughtItem && gameState === 'RETURNING') {
                    this.caughtItem.x = tipX;
                    this.caughtItem.y = tipY + this.caughtItem.radius/2;
                    this.caughtItem.draw();
                }
            },
            
            reset: function() {
                gameState = 'AIMING';
                this.length = this.minLength;
                this.caughtItem = null;
                this.currentSpeed = this.baseSpeed;
            }
        };

        // --- OBJETOS (CLASE) ---
        class Item {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.caught = false;

                // Configuraci√≥n seg√∫n el tipo
                switch(type) {
                    case 'gold_big':
                        this.emoji = 'üí∞'; this.radius = 35; this.value = 500; this.weight = 5; break;
                    case 'gold_small':
                        this.emoji = 'üåï'; this.radius = 15; this.value = 100; this.weight = 1; break;
                    case 'rock_big':
                        this.emoji = 'ü™®'; this.radius = 30; this.value = 10; this.weight = 7; break;
                    case 'rock_small':
                        this.emoji = 'ü™®'; this.radius = 15; this.value = 5; this.weight = 3; break;
                    case 'bomb':
                        this.emoji = 'üí£'; this.radius = 20; this.value = -200; this.weight = 0; break;
                }
            }

            draw() {
                if(this.caught) return; // Si ya lo trae el gancho, no lo dibujamos aqu√≠
                ctx.font = `${this.radius * 2}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.emoji, this.x, this.y);
                
                // (Opcional) Dibujar c√≠rculo de colisi√≥n para depurar
                // ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.stroke();
            }
        }

        let items = [];

        function generateLevel() {
            items = [];
            // Generar objetos aleatorios en la zona de tierra
            for(let i=0; i<15; i++) {
                let types = ['gold_big', 'gold_small', 'gold_small', 'rock_big', 'rock_small', 'rock_small', 'bomb'];
                let type = types[Math.floor(Math.random() * types.length)];
                let x = Math.random() * (canvas.width - 60) + 30;
                let y = groundLevel + 50 + Math.random() * (canvas.height - groundLevel - 100);
                items.push(new Item(type, x, y));
            }
        }

        // --- CONTROL PRINCIPAL (LANZAR) ---
        canvas.addEventListener('pointerdown', () => { // pointerdown funciona mejor en m√≥viles
            if (gameState === 'AIMING') {
                gameState = 'FIRING';
                hook.currentSpeed = hook.baseSpeed;
            }
        });

        // --- COLISIONES ---
        function checkCollisions() {
            if (gameState !== 'FIRING') return;

            let tipX = hook.x + Math.cos(hook.angle) * hook.length;
            let tipY = hook.y + Math.sin(hook.angle) * hook.length;

            for (let item of items) {
                if (item.caught) continue;

                // Distancia simple entre dos puntos
                let dx = tipX - item.x;
                let dy = tipY - item.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < item.radius + 5) { // +5 margen para el gancho
                    // ¬°IMPACTO!
                    
                    if(item.type === 'bomb') {
                        // L√≥gica de bomba
                        gameState = 'RETURNING';
                        hook.currentSpeed = hook.baseSpeed * 2; // Regresa r√°pido
                        score += item.value; // Resta puntos
                        if(score < 0) score = 0;
                        scoreEl.innerText = score;
                        showFloatText("üí• BOMBA! -$200", tipX, tipY, 'red');
                        // Eliminar bomba y objetos cercanos
                        items = items.filter(i => i !== item && Math.sqrt((i.x-item.x)**2 + (i.y-item.y)**2) > 100);

                    } else {
                        // Agarrar objeto
                        gameState = 'RETURNING';
                        hook.caughtItem = item;
                        item.caught = true;
                        // Calcular velocidad de retorno seg√∫n peso (m√°s peso, menos velocidad)
                        hook.currentSpeed = Math.max(1.5, hook.baseSpeed - item.weight);
                    }
                    break; // Solo agarra uno a la vez
                }
            }
        }

        function showFloatText(text, x, y, color = '#FFD700') {
            let el = document.createElement('div');
            el.className = 'float-score';
            el.innerText = text;
            el.style.left = (container.offsetLeft + x) + 'px';
            el.style.top = (container.offsetTop + y) + 'px';
            el.style.color = color;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        // --- BUCLE PRINCIPAL DEL JUEGO ---
        function gameLoop() {
            // 1. Limpiar pantalla
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Actualizar l√≥gica
            hook.update();
            checkCollisions();

            // 3. Dibujar todo
            miner.draw();
            for(let item of items) {
                item.draw();
            }
            hook.draw();

            requestAnimationFrame(gameLoop);
        }

        // INICIAR
        generateLevel();
        gameLoop();

    </script>
</body>
        </html>
