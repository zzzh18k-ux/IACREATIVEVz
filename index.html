<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minero Espacial Alternativo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            /* Cursor de mira para indicar que se puede hacer clic */
            cursor: crosshair; 
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
    // --- CONFIGURACIÓN INICIAL ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Tamaño del canvas (ajustado para móviles o escritorio)
    canvas.width = window.innerWidth > 480 ? 400 : window.innerWidth - 20;
    canvas.height = window.innerHeight > 800 ? 700 : window.innerHeight - 20;

    // Variables de estado del juego
    let score = 0;
    let timeLeft = 60; // 60 segundos de juego
    let gameState = 'START'; // START, PLAYING, GAMEOVER
    let lastTime = 0;

    // --- OBJETOS DEL JUEGO ---

    // El Gancho (La nave y la garra)
    const claw = {
        x: canvas.width / 2,
        y: 50, // Posición de la nave arriba
        angle: Math.PI / 2, // Empieza apuntando hacia abajo (90 grados)
        angleSpeed: 0.02,
        angleDir: 1,
        length: 20,
        maxLength: canvas.height - 50,
        state: 'SWINGING', // SWINGING (balanceando), SHOOTING (disparando), RETRACTING (retrayendo)
        shootSpeed: 8,
        retractSpeed: 8,
        caughtItem: null,
        
        update: function() {
            if (this.state === 'SWINGING') {
                // Balanceo de lado a lado (entre 45 y 135 grados aprox)
                this.angle += this.angleSpeed * this.angleDir;
                if (this.angle > Math.PI * 0.75 || this.angle < Math.PI * 0.25) {
                    this.angleDir *= -1;
                }
            } else if (this.state === 'SHOOTING') {
                this.length += this.shootSpeed;
                // Si llega al límite o toca el fondo
                if (this.length >= this.maxLength) {
                    this.state = 'RETRACTING';
                }
            } else if (this.state === 'RETRACTING') {
                // La velocidad de retracción depende del peso del objeto atrapado
                let currentRetractSpeed = this.retractSpeed;
                if (this.caughtItem) {
                    currentRetractSpeed = this.retractSpeed / this.caughtItem.weight;
                }
                this.length -= currentRetractSpeed;
                
                // Si regresa al inicio
                if (this.length <= 20) {
                    this.length = 20;
                    this.state = 'SWINGING';
                    if (this.caughtItem) {
                        score += this.caughtItem.value;
                        // Eliminar el ítem atrapado de la lista de ítems
                        items = items.filter(i => i !== this.caughtItem);
                        this.caughtItem = null;
                    }
                }
            }
        },

        draw: function() {
            // Dibujar la línea del gancho
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            // Calcular la punta del gancho usando trigonometría
            let endX = this.x + this.length * Math.cos(this.angle);
            let endY = this.y + this.length * Math.sin(this.angle);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#ff6f00'; // Color naranja para la cuerda
            ctx.lineWidth = 3;
            ctx.stroke();

            // Dibujar la "nave" base arriba
            ctx.fillStyle = '#ff4500'; // Naranja rojizo
            ctx.beginPath();
            ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
            ctx.fill();

            // Dibujar la punta de la garra
            ctx.fillStyle = '#ff8c00';
            ctx.beginPath();
            ctx.arc(endX, endY, 8, 0, Math.PI * 2);
            ctx.fill();

            return { x: endX, y: endY }; // Devolver la posición de la punta para colisiones
        }
    };

    // Los Ítems (Monedas, rocas)
    let items = [];

    class Item {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            // Definir propiedades según el tipo (diferentes colores y valores)
            if (type === 'coin') {
                this.radius = 20;
                this.value = 50;
                this.color = '#00ffff'; // Cian brillante (en vez de oro)
                this.weight = 1; // Ligero
            } else if (type === 'rock') {
                this.radius = 25;
                this.value = 10;
                this.color = '#8d6e63'; // Marrón cobrizo (en vez de gris)
                this.weight = 3; // Pesado (sube lento)
            } else if (type === 'gem') {
                 this.radius = 15;
                 this.value = 100;
                 this.color = '#ff00ff'; // Magenta (muy valioso)
                 this.weight = 1;
            }
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Un pequeño brillo
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(this.x - this.radius/3, this.y - this.radius/3, this.radius/4, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Función para crear niveles aleatorios
    function spawnItems() {
        items = [];
        // Crear 8 monedas
        for (let i = 0; i < 8; i++) {
            items.push(new Item(Math.random() * (canvas.width - 40) + 20, Math.random() * (canvas.height / 2) + canvas.height / 2 - 50, 'coin'));
        }
        // Crear 4 rocas
        for (let i = 0; i < 4; i++) {
            items.push(new Item(Math.random() * (canvas.width - 40) + 20, Math.random() * (canvas.height / 2) + canvas.height / 2 - 50, 'rock'));
        }
        // Crear 2 gemas
        for (let i = 0; i < 2; i++) {
             items.push(new Item(Math.random() * (canvas.width - 40) + 20, Math.random() * (canvas.height / 2) + canvas.height / 2 - 50, 'gem'));
        }
    }

    // --- LÓGICA PRINCIPAL ---

    // Detectar colisión entre la punta del gancho y un ítem
    function checkCollision(clawTipX, clawTipY, item) {
        const dx = clawTipX - item.x;
        const dy = clawTipY - item.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        // Si la distancia es menor que el radio del ítem + un poco de margen
        return distance < item.radius + 5;
    }

    // Bucle principal del juego
    function gameLoop(timeStamp) {
        // Calcular tiempo delta para el temporizador
        let deltaTime = timeStamp - lastTime;
        lastTime = timeStamp;

        // 1. Limpiar pantalla (Fondo Azul Oscuro Espacial)
        ctx.fillStyle = '#0a0a2a'; // Azul oscuro profundo
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Dibujar algunas estrellas simples
        ctx.fillStyle = '#ffffff';
        for(let i=0; i<30; i++) {
             // Usamos una semilla simple basada en i para que las estrellas no se muevan
            let starX = (Math.sin(i*123) * canvas.width + canvas.width) % canvas.width;
            let starY = (Math.cos(i*456) * canvas.height + canvas.height) % canvas.height;
            ctx.fillRect(starX, starY, 2, 2);
        }


        if (gameState === 'PLAYING') {
            // Actualizar temporizador
            if (deltaTime) { timeLeft -= deltaTime / 1000; }
            if (timeLeft <= 0) {
                timeLeft = 0;
                gameState = 'GAMEOVER';
            }

            // 2. Actualizar objetos
            claw.update();

            // Si el gancho está disparando, verificar colisiones
            if (claw.state === 'SHOOTING') {
                let clawTipX = claw.x + claw.length * Math.cos(claw.angle);
                let clawTipY = claw.y + claw.length * Math.sin(claw.angle);

                for (let item of items) {
                    if (checkCollision(clawTipX, clawTipY, item)) {
                        claw.state = 'RETRACTING';
                        claw.caughtItem = item;
                        break; // Solo agarrar uno a la vez
                    }
                }
            }
            
            // Si tenemos un ítem atrapado, moverlo con el gancho
            if (claw.caughtItem) {
                 claw.caughtItem.x = claw.x + claw.length * Math.cos(claw.angle);
                 claw.caughtItem.y = claw.y + claw.length * Math.sin(claw.angle);
            }

            // Verificar si se acabaron los ítems para reiniciar el nivel
            if (items.length === 0 && claw.state === 'SWINGING') {
                spawnItems();
            }

        }

        // 3. Dibujar objetos
        // Dibujar ítems (excepto el que está siendo atrapado, ese se dibuja al final sobre el gancho)
        items.forEach(item => {
            if (item !== claw.caughtItem) item.draw();
        });
        
        // Dibujar gancho
        claw.draw();

        // Dibujar el ítem atrapado encima de la punta del gancho
        if (claw.caughtItem) {
             claw.caughtItem.draw();
        }


        // 4. Dibujar UI (Interfaz de usuario)
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText('Puntos: ' + score, 20, 30);
        ctx.fillText('Tiempo: ' + Math.ceil(timeLeft) + 's', canvas.width - 120, 30);

        // Mensajes de estado
        ctx.textAlign = 'center';
        if (gameState === 'START') {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ffff';
            ctx.font = '30px Arial';
            ctx.fillText('MINERO ESPACIAL', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '20px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText('Toca para empezar a jugar', canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText('Atrapa los orbes cian, evita las rocas pesadas', canvas.width / 2, canvas.height / 2 + 50);
        } else if (gameState === 'GAMEOVER') {
             ctx.fillStyle = 'rgba(0,0,0,0.7)';
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             ctx.fillStyle = '#ff4500';
             ctx.font = '40px Arial';
             ctx.fillText('¡TIEMPO FUERA!', canvas.width / 2, canvas.height / 2);
             ctx.fillStyle = '#fff';
             ctx.font = '25px Arial';
             ctx.fillText('Puntuación Final: ' + score, canvas.width / 2, canvas.height / 2 + 40);
             ctx.font = '20px Arial';
             ctx.fillText('Toca para reiniciar', canvas.width / 2, canvas.height / 2 + 80);
        }
        ctx.textAlign = 'left'; // Resetear alineación

        requestAnimationFrame(gameLoop);
    }

    // --- CONTROL DEL JUGADOR ---
    function handleInput(e) {
        e.preventDefault(); // Evitar zoom o scroll en móviles

        if (gameState === 'START') {
            gameState = 'PLAYING';
            score = 0;
            timeLeft = 60;
            spawnItems();
            lastTime = performance.now();
        } else if (gameState === 'PLAYING') {
            // Solo disparar si está balanceándose
            if (claw.state === 'SWINGING') {
                claw.state = 'SHOOTING';
            }
        } else if (gameState === 'GAMEOVER') {
             gameState = 'START';
        }
    }

    // Escuchar clics del mouse y toques en pantalla
    canvas.addEventListener('mousedown', handleInput);
    canvas.addEventListener('touchstart', handleInput, { passive: false });

    // Iniciar el juego
    // spawnItems(); // Se llama al iniciar el juego desde el estado START
    requestAnimationFrame(gameLoop);

</script>

</body>
</html>
